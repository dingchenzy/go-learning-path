标准库
https://golang.org/pkg 和 https://godoc.org

Go 语言的工具链将源代码及其依赖转换成计算机识别的机器指令

Go 原生支持 Unicode
	Unicode 是一种包含全世界任何语言的字符集

go 命令
	run 直接执行命令
	build 编译代码，静态编译，不需要担心系统库更新影响编译后的程序不能使用
	doc 查看帮助手册

main 的特殊，定义了一个独立可执行的程序，并不是一个库，main 包中的 main 函数是整个程序执行时的入口。

goimports 工具可以自动添加 go 程序的 import

slice 概念
	左闭右开概念
		区间内包括第一个元素，但是不包括最后一个
	s[m:n]
		省略 m 或 n 任何一个，将会自动追加 0 或 len(s)
	
os 包：提供一些与操作系统交互的函数和变量
	获取命令行参数
		os.Args 是一个字符串的切片，用来获得控制台用户输入的参数，os.Args[0] 是获得命令本身
		os.Args[1:] 或 os.Args[1:len(os.Args)]

空值的内容
	string ""
	int 0

i++ i-- 与 C 中的 i++ i-- 区别
	Go 语言中的 i++ 和 i-- 不可以作为赋值使用，这是语法，并不是表达式
	Go 中的 i++ 不可以使用 ++i 因为 Go 中的是语法并不是像 C 中代表的是表达式

声明变量的方式
	var str string	# 声明空值
	str := "a"		# 简短声明，隐式的声明变量的类型，但是无法用于包变量
	var str = "a"	# 最少用
	var str string = "a"	# 长格式声明，会声明变量的类型，比较直观
	
为什么 map 中的值是随机的
	为了防止程序过于依赖 map 的遍历
	
printf 的格式化
	// 使用这种方式打印的 [1] 还是会找到第一个参数
	printf(%d, %[1]d, %d, 1, 2)
	%d          十进制整数
	%x, %o, %b  十六进制，八进制，二进制整数。
	%f, %g, %e  浮点数： 3.141593 3.141592653589793 3.141593e+00
	%t          布尔：true或false
	%c          字符（rune） (Unicode码点)
	%s          字符串
	%q          带双引号的字符串"abc"或带单引号的字符'c'
	%v          变量的自然形式（natural format）
	%T          变量的类型
	%%          字面上的百分号标志（无操作数）

const 常量的定义
	程序编译时运行后都不会变化的值
	常量声明和变量声明一般会在包级别，在包级别声明是对整个包共享的
	
妙用 io.Copy
	例如下载一个图片，如果图片过大，使用 ioutil.ReadAll 这种方式会将内容全部读取到内存中
	会消耗很多内存，使用 io.Copy 方法可以解决这种方式，直接将内容输入到指定的输入流中，并不会使用缓冲区
	
测试网站的缓存策略
	可以使用并发访问测试网站的缓存状态，看到每次访问的时间
	工具的实现就是基于
	time.Since channel goroutine 这几种方式的组和，可以看到 1.6 章的程序

命名 
	包内包外的可见性
		首字母大写则在包外可见
		尽量使用大小写混写的方式，不使用 _ 下划线分割的方式
	声明
		const type func var
		常量  类型 函数 变量

变量的生命周期
	var global *int

	func f() {
		var x int
		x = 1
		global = &x
	}

	func g() {
		y := new(int)
		*y = 1
	}
	
	上面的程序中 f 函数返回后，变量并不会被回收，因为在程序中，Go 编译器还是可以通过 global 变量找到 x 变量的内存地址
		这种函数执行完毕，但是变量并没有被回收的现象称为变量的逃逸
	上面的程序中 g 函数返回后，y 变量将会被立刻回收
	特定的就是 f 中的 x 变量因为函数返回后依然不会被释放，所以是在堆中定义的
			   g 中的 y 变量因为是函数返回后就会被释放，所以是在栈中定义的
	默认情况下，函数的执行都是使用栈来执行的

赋值与定义
	赋值，是一个变量已经存在，然后使用定义完成的变量名赋值内容
	定义，是一个变量不存在，使用简短声明或者是使用 new 函数创建出一个新的变量
		new 函数的定义
			实际上就是定义一个类型，然后会返回一个类型的指针地址
			复现 new 函数
				func new(int) *int {
					var i int
					return &i
				}

元组赋值
	可以同时更新多个变量，使用时，赋值右边的表达式会先使用表达式进行求值，之后统一更新左边的变量，用于处理同时出现在左右两边的变量
	x, y = y, x			a[i], a[j] = a[j], a[i]			// 能够实现变量内容的互换

Go 的习惯
	在 if 中处理错误，然后直接返回结果，不需要代码缩进
	
if 语句
	下级的 if 可以获取上级 if 的 if 隐式升级变量
	if x := 1; x == 0 {
		fmt.Println(x)
	} else if y:= 2; y == 2 {
		fmt.Println(x, y)
	}
	使用这种方式可以打印 x 和 y 的变量

变量的作用域
	包声明
	函数体词法域
	if for 隐式初始化词法域
	if for 内部的循环体词法域
	作用域案例
		var cwd string

		func printwd() {
			fmt.Println("printwd : ", cwd)
		}
		func main() {
			cwd, err := os.Getwd()
			if err != nil {
				log.Fatal(err)
			}
			printwd()
			fmt.Println("main : ", cwd)
		}
		输出：
			printwd :
			main :  D:\sun_Ubuntu\rootfs\mnt\ansible\go_directory\project\src\learning_go\aaa
		这个案例中，可以看到包级别变量并未更新，因为定义 cwd 和 err 时，使用了 := 简短声明方式，程序会认为 err 和 cwd 并未定义并重新定义，从而出现这种情况。
	避免这种情况
		func main() {
			var err error
			cwd, err = os.Getwd()
		}
		只需要在函数级别重新定义 err 变量即可，避免使用 := 简短声明
数据类型
	整型 rune 等价于 int32
		int 有符号和无符号 uint
		取模符号在 Go 中的应用，取模结果的符号会依赖于被取模数，例如 -5%3 和 -5%-3 的取模结果都等于 -2
		除法，在 Go 中的除法，如果是整数相除，有小数点会截断小数点后的内容
		如果 + 的位数超过了整数的容量，那么有符号的整型可能会变成负数，无符号的整型可能会变成 0
			var a uint8 = 127
			var b int8 = 127
			fmt.Println(a, a+1)
			fmt.Println(b, b+1)
		输出结果：
			127 128
			127 -128
		如果 int32 类型和 int64 类型做计算，最好是将 int32 转换为 int64 做计算
	布尔型
		&& 符号比 || 的优先级要高
		&& = *           || = +
		bool 转换为数字
			func btoi(b bool) int {
				if b {
					return 1
				}
				return 0
			}
		数字转换为 bool
			func itob(i int) bool {
				return i != 0
			}
			
包的导入
	import 语句导入，导入包的路径在 $GOPATH/src/project
		导入的包主体需要在 package 中声明该包的名称
	init 函数
		初始化函数，用来声明变量或者是必须要最初执行的初始化操作
		初始化的优先级是   例如 A 要导入 B 这个包，那么就会在程序执行时，先执行 B 这个包中的 init 函数，之后执行 A 包中的 init 函数，最后执行 A 包中的语句
		
作用域
	作用域与生命周期
		作用域是源代码的文本区域
		生命周期是例如某个变量存在的时间
	声明语句的词法域决定了作用域范围的大小，在程序编译时，会首先从最内层的词法域进行查找变量的声明，最内层的词法域中有的局部变量则就获取不到其他的外部变量
	
测试一个字符串的前缀
	return len(s) >= len(prefix) && s[:len(prefix)] == prefix
	return len(s) >= len(suffix) && s[len(s)-len(suffix):] == suffix
	
常量
	使用 const 定义常量，常量一旦定义将不可以修改，所有的常量都可以在 编译期就可以运行，这也就是说运行时的错误可以在编译时就可以发现
		编译时发现的错误：例如字符串的索引超过字符串下标等常量定义变量时出现的错误都会在 go build 中定义，go run 则会检查程序的逻辑
	用法：
		可以用来定义一些构成类型的部分，例如数组的长度等。
		const IPv4Len = 4
		func parseIPv4(s string) IP {
			var p [IPv4Len]byte
		}
	iota 常量生成器（枚举）
		第一个声明变量的所在行，iota 会置为零，然后在每一个有常量的声明行加一
		const (
			//a = (iota + 1)	// 从 1 开始
			a = iota		// 从 0 开始
			b
			c
			d
			e
			f
		)

数组
	固定长度的特定类型元素组成的序列，可以由零个或者是多个元素组成。
	元素可以通过数组的下标进行访问，内置的 len 函数将会返回数组中元素的个数
	定义数组的类型可以进行比较，那么数组也是可以直接比较的（最好可以使用 散列算法 对数组进行 hash，然后对比 hash 码

slice
	如果要判断一个 slice 是否为空，要使用 len(slice) == 0 判断而非 slice == nil 判断
	容量与长度
		容量的内容是代表底层匿名函数所包含的整个组的数量，其他没有被使用的元素是留给未来使用
		长度是代表数组中已经存在的元素数量
	因为是引用类型，所以可以在这个定义上定义 slice 只使用一块内存空间例如，去除 slice 为空的元素
		package main

		import "fmt"

		// 传入 slice，使用 for range 判断值是否有空，不为空则保存，如果为空则忽略
		func nonempty(x []int) []int {
			y := 0
			for i, v := range x {
				if v != 0 {
					// 这里不可以写 i，因为如果使用 i，则判断为 0 时，那么索引也不会被调用到
					//x[i] = v
					x[y] = v
					y++
				}
			}
			return x[:y]
		}

		func main() {
			x := []int{1,2,0,4,5}
			fmt.Println(nonempty(x))
		}
		// 这段代码在底层使用的是同一个 slice
	
map
	由 key 和 value 组成，key 的类型必须是可以进行比较的，value 的类型则不限
	可以通过 value, ok := mapname["key"]	这种方式判断 key 不存在于 map 中
		     if !ok {
				fmt.Println("key is not exist")
			 }
	map 这种类型是没有顺序排列的，slice 可以通过 strings.Sort 进行排序，map 则是无序的
	
struct
	是一种聚合的数据类型，由多个类型组成，struct 内不同类型的声明称为 struct 的不同的成员
	成员的隐藏和外放通过成员的首字母是否大写来决定
		成员首字母没有大写使用隐式赋值也是不可以的（但是可以通过调用一个外放的函数来修改包内的 struct 内容）
		package p

		type T struct {
			a, b int
		}

		func ChangeT(t T, a int) T {
			return T{t.a + a, t.b*a}
		}

		package main

		import (
			"fmt"
			"learning_go/aaa/p"
		)

		func main() {
			var a p.T
			a = p.ChangeT(a, 10)
			fmt.Println(a)	// 10, 0
		}
	如果结构体较大可以使用指针方式传入，因为这样就省去了函数复制结构体的那一部分内存
		func ChangeT(t *T, a int) {}
	创建指针类型结构体的方式
		type a struct{}
		pp := *a{}
		pp := new(a)
		*pp := a{}
	结构体比较
		只要结构体内部的类型可以比较，那么结构体就可以进行比较整个结构体也可以进行比较
		因为可以比较，结构体可以作为 map 类型的键名
		package main
		import "fmt"
		func main() {
			var str = &ruct1{
				name: "chen",
				age:  13,
			}
			var map1 = make(map[*ruct1]int)

			map1[str] = 1
			for i, v := range map1 {
				fmt.Println(i.age)
				fmt.Println(v)
			}
		}

		type ruct1 struct {
			name string
			age  int
		}

json
	是一种用于发送和接收结构化信息的标准协议，类似的协议中还有 XML 协议。
	编组，将结构体或者是 slice 转换成 json 的过程称为编组
	
	解组，将 json 拆分为 slice 或 struct 的过程称为解组
	
接口
	是对其他类型的抽象和概括，可以让函数更加的灵活和适应能力，因为不会将一些实现细节绑定到一起
	可以满足隐式实现的。
	接口类型是一种抽象的类型，也就是说当你有看到一个接口类型的值时，你只知道你可以用它的方法来实现哪些功能，但是不知道其内部是怎么实现的
	与 struct 的实验
		1. 非指针类型 struct 调用指针类型的方法时，可以直接调用，而接口不可以
		2. 指针类型的 struct 不可以调用非指针类型方法
		3. 赋值给接口的必须要实现指定的方法才可以进行赋值
		4. 任何实现接口方法的 struct 都可以赋值给接口
		5. 接口能够实现多态
	多态的实现：同一个函数可以使用两个结构体
		package main

		import "fmt"

		type sumer interface {
			Call()
		}

		type dog struct {
			name string
		}

		type cat struct {
			name string
		}

		func (d *dog) Call() {
			fmt.Printf("%s call is wangwang\n", d.name)
		}

		func (c *cat) Call() {
			fmt.Printf("%s call is miaomiao\n", c.name)
		}

		func animal(c sumer) {
			c.Call()
		}

		func main() {
			var dog1 = &dog{name: "dog"}
			var cat1 = &cat{name: "cat"}

			animal(dog1)
			animal(cat1)
		}

并发
	并发是同一个处理器上运行两个进程，然后处理器保存进程上下文不停的切换
	并行是两个处理器同时运行两个进程
	进程与线程
	- 进程与线程概述
	  - 进程是计算机资源分配的最小单位
	  - 线程是计算机资源调度的最小单位，在同一个进程下的线程可以共享进程资源
	  - 同个进程下的线程间需要通过 CPU 切换上下文但是不需要创建新的虚拟内存空间比不同进程切换更加轻量
	- 进程间的通信
	  - 因为不同的进程之间不是共享内存的，并且虚拟内存是相互隔离的，所以需要使用 IPC 进程间调用实现
	  - 而线程就不需要这种机制，因为本身如果线程在同一个进程之下是共享同一个虚拟内存空间的，所以不需要这种机制
	  - IO 多路复用，维持一个线程队列，让一个或者是多个线程去线程队列中领任务去完成
	  - 单个线程的 IO 多路复用就是 Redis Nodejs 这种，因为不需要 CPU 频繁的切换上下文也提升了性能
	  - 多个线程的 IO 多路复用就是 Golang 的协程实现方式，让程序自己管理协程，将协程控制到一定的数量之后构造个规则实现调度
	协程的使用
		1. 不能让协程没有运行完 main 函数就提前终止因为 main 函数是程序的主协程
	信道的使用
		1. 可以使用 chan 信道的阻塞特性，让 main 函数等待 goroutime 协程执行完毕后退出
	select 语句判断
		select 语句可以判断信道中是否还有数据，如果赋值不成功将会自动的判断为 false 将会不执行
		select {
		case v, ok := <-ch:
			if !ok {
				fmt.Println("recevice value is channel close")
				ch1 <- 1
				return
			}
			fmt.Printf("receive value is %d\n", v)
		}
		当信道被关闭，ok 为 false，如果没有关闭则为 true
	使用 for 循环读取信道中的内容
		func main() {
			chan1 := make(chan int, 3)
			chan1 <- 1
			chan1 <- 2
			chan1 <- 3
			close(chan1)		// 必须要关闭信道，才可以使用 for range 读取信道中的内容否则就会报死锁错误
			for i := range chan1 {
				fmt.Println(i)
			}
		}
	并发安全
		加锁和解锁 sync.Mutex 定义这个类型即可
		package main

		import (
			"fmt"
			"log"
			"sync"
		)

		type Money struct {
			// 创建带锁的一个结构体内部成员
			// 保证数据安全
			lock     sync.Mutex
			Moneyint int
		}

		func (m *Money) Add(addint int) {
			m.lock.Lock()
			defer m.lock.Unlock()
			m.Moneyint += addint
		}

		func (m *Money) Del(delint int) {
			m.lock.Lock()
			defer m.lock.Unlock()
			if m.Moneyint >= delint {
				m.Moneyint -= delint
			} else {
				log.Fatal("money is not enoung")
			}
		}

		func (m *Money) Get() {
			fmt.Println("human have money is", m.Moneyint)
		}

		func main() {
			a := new(Money)
			// 保证进程安全，添加 wait 等待每个协程完成后都会 done
			c := new(sync.WaitGroup)
			a.Add(1000)
			c.Add(100)
			for i := 1; i <= 100; i++ {
				go func() {
					a.Del(10)
					c.Done()
				}()
			}
			c.Wait()
			defer a.Get()
		}

		
package 用法

http package
	handle 以及 listen 监听到 socket 后，当用户访问会为每个用户分配一个 goroutine
	http.Handle 面向对象的方式，结构体需要实现 ServeHTTP 方法才可以赋值到 http.Handle

unicode pakcage
	unicode 提供给用户了 IsDigit IsLetter IsUpper 等动作，判断字符串的类型
	
strconv package
	提供了布尔型，整数型和浮点数以及对应字符串的相互转换

bufio
	NewScanner 创建一个 scanner 对象
	scanner.Split(bufio.ScanWords) 用来将字符串识别出单词并进行分割

json
	json.Marshal 将 struct 或 slice 进行编码
	json.MarshalIndent 将编码出的内容进行格式化
	
	json tag 标注
		Name string `json:"name",omitempty`			// name 代表转换为 json 后的字段名称，omitempty 标识当 Go 语言结构体成员为空或零值时不生成 JSON 对象
