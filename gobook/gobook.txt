标准库
https://golang.org/pkg 和 https://godoc.org

Go 语言的工具链将源代码及其依赖转换成计算机识别的机器指令

Go 原生支持 Unicode
	Unicode 是一种包含全世界任何语言的字符集

go 命令
	run 直接执行命令
	build 编译代码，静态编译，不需要担心系统库更新影响编译后的程序不能使用
	doc 查看帮助手册

main 的特殊，定义了一个独立可执行的程序，并不是一个库，main 包中的 main 函数是整个程序执行时的入口。

goimports 工具可以自动添加 go 程序的 import

slice 概念
	左闭右开概念
		区间内包括第一个元素，但是不包括最后一个
	s[m:n]
		省略 m 或 n 任何一个，将会自动追加 0 或 len(s)
	
os 包：提供一些与操作系统交互的函数和变量
	获取命令行参数
		os.Args 是一个字符串的切片，用来获得控制台用户输入的参数，os.Args[0] 是获得命令本身
		os.Args[1:] 或 os.Args[1:len(os.Args)]

空值的内容
	string ""
	int 0

i++ i-- 与 C 中的 i++ i-- 区别
	Go 语言中的 i++ 和 i-- 不可以作为赋值使用，这是语法，并不是表达式
	Go 中的 i++ 不可以使用 ++i 因为 Go 中的是语法并不是像 C 中代表的是表达式

声明变量的方式
	var str string	# 声明空值
	str := "a"		# 简短声明，隐式的声明变量的类型，但是无法用于包变量
	var str = "a"	# 最少用
	var str string = "a"	# 长格式声明，会声明变量的类型，比较直观
	
为什么 map 中的值是随机的
	为了防止程序过于依赖 map 的遍历
	
printf 的格式化
	// 使用这种方式打印的 [1] 还是会找到第一个参数
	printf(%d, %[1]d, %d, 1, 2)
	%d          十进制整数
	%x, %o, %b  十六进制，八进制，二进制整数。
	%f, %g, %e  浮点数： 3.141593 3.141592653589793 3.141593e+00
	%t          布尔：true或false
	%c          字符（rune） (Unicode码点)
	%s          字符串
	%q          带双引号的字符串"abc"或带单引号的字符'c'
	%v          变量的自然形式（natural format）
	%T          变量的类型
	%%          字面上的百分号标志（无操作数）

const 常量的定义
	程序编译时运行后都不会变化的值
	常量声明和变量声明一般会在包级别，在包级别声明是对整个包共享的
	
妙用 io.Copy
	例如下载一个图片，如果图片过大，使用 ioutil.ReadAll 这种方式会将内容全部读取到内存中
	会消耗很多内存，使用 io.Copy 方法可以解决这种方式，直接将内容输入到指定的输入流中，并不会使用缓冲区
	
测试网站的缓存策略
	可以使用并发访问测试网站的缓存状态，看到每次访问的时间
	工具的实现就是基于
	time.Since channel goroutine 这几种方式的组和，可以看到 1.6 章的程序

命名 
	包内包外的可见性
		首字母大写则在包外可见
		尽量使用大小写混写的方式，不使用 _ 下划线分割的方式
	声明
		const type func var
		常量  类型 函数 变量

变量的生命周期
	var global *int

	func f() {
		var x int
		x = 1
		global = &x
	}

	func g() {
		y := new(int)
		*y = 1
	}
	
	上面的程序中 f 函数返回后，变量并不会被回收，因为在程序中，Go 编译器还是可以通过 global 变量找到 x 变量的内存地址
		这种函数执行完毕，但是变量并没有被回收的现象称为变量的逃逸
	上面的程序中 g 函数返回后，y 变量将会被立刻回收
	特定的就是 f 中的 x 变量因为函数返回后依然不会被释放，所以是在堆中定义的
			   g 中的 y 变量因为是函数返回后就会被释放，所以是在栈中定义的
	默认情况下，函数的执行都是使用栈来执行的

赋值与定义
	赋值，是一个变量已经存在，然后使用定义完成的变量名赋值内容
	定义，是一个变量不存在，使用简短声明或者是使用 new 函数创建出一个新的变量
		new 函数的定义
			实际上就是定义一个类型，然后会返回一个类型的指针地址
			复现 new 函数
				func new(int) *int {
					var i int
					return &i
				}

元组赋值
	可以同时更新多个变量，使用时，赋值右边的表达式会先使用表达式进行求值，之后统一更新左边的变量，用于处理同时出现在左右两边的变量
	x, y = y, x			a[i], a[j] = a[j], a[i]			// 能够实现变量内容的互换

Go 的习惯
	在 if 中处理错误，然后直接返回结果，不需要代码缩进
	
if 语句
	下级的 if 可以获取上级 if 的 if 隐式升级变量
	if x := 1; x == 0 {
		fmt.Println(x)
	} else if y:= 2; y == 2 {
		fmt.Println(x, y)
	}
	使用这种方式可以打印 x 和 y 的变量

变量的作用域
	包声明
	函数体词法域
	if for 隐式初始化词法域
	if for 内部的循环体词法域
	作用域案例
		var cwd string

		func printwd() {
			fmt.Println("printwd : ", cwd)
		}
		func main() {
			cwd, err := os.Getwd()
			if err != nil {
				log.Fatal(err)
			}
			printwd()
			fmt.Println("main : ", cwd)
		}
		输出：
			printwd :
			main :  D:\sun_Ubuntu\rootfs\mnt\ansible\go_directory\project\src\learning_go\aaa
		这个案例中，可以看到包级别变量并未更新，因为定义 cwd 和 err 时，使用了 := 简短声明方式，程序会认为 err 和 cwd 并未定义并重新定义，从而出现这种情况。
	避免这种情况
		func main() {
			var err error
			cwd, err = os.Getwd()
		}
		只需要在函数级别重新定义 err 变量即可，避免使用 := 简短声明
数据类型
	整型 rune 等价于 int32
		int 有符号和无符号 uint
		取模符号在 Go 中的应用，取模结果的符号会依赖于被取模数，例如 -5%3 和 -5%-3 的取模结果都等于 -2
		除法，在 Go 中的除法，如果是整数相除，有小数点会截断小数点后的内容
		如果 + 的位数超过了整数的容量，那么有符号的整型可能会变成负数，无符号的整型可能会变成 0
			var a uint8 = 127
			var b int8 = 127
			fmt.Println(a, a+1)
			fmt.Println(b, b+1)
		输出结果：
			127 128
			127 -128
		如果 int32 类型和 int64 类型做计算，最好是将 int32 转换为 int64 做计算
	布尔型
		&& 符号比 || 的优先级要高
		&& = *           || = +
		bool 转换为数字
			func btoi(b bool) int {
				if b {
					return 1
				}
				return 0
			}
		数字转换为 bool
			func itob(i int) bool {
				return i != 0
			}
			
包的导入
	import 语句导入，导入包的路径在 $GOPATH/src/project
		导入的包主体需要在 package 中声明该包的名称
	init 函数
		初始化函数，用来声明变量或者是必须要最初执行的初始化操作
		初始化的优先级是   例如 A 要导入 B 这个包，那么就会在程序执行时，先执行 B 这个包中的 init 函数，之后执行 A 包中的 init 函数，最后执行 A 包中的语句
		
作用域
	作用域与生命周期
		作用域是源代码的文本区域
		生命周期是例如某个变量存在的时间
	声明语句的词法域决定了作用域范围的大小，在程序编译时，会首先从最内层的词法域进行查找变量的声明，最内层的词法域中有的局部变量则就获取不到其他的外部变量
	
测试一个字符串的前缀
	return len(s) >= len(prefix) && s[:len(prefix)] == prefix
	return len(s) >= len(suffix) && s[len(s)-len(suffix):] == suffix
	
常量
	使用 const 定义常量，常量一旦定义将不可以修改，所有的常量都可以在 编译期就可以运行，这也就是说运行时的错误可以在编译时就可以发现
		编译时发现的错误：例如字符串的索引超过字符串下标等常量定义变量时出现的错误都会在 go build 中定义，go run 则会检查程序的逻辑
	用法：
		可以用来定义一些构成类型的部分，例如数组的长度等。
		const IPv4Len = 4
		func parseIPv4(s string) IP {
			var p [IPv4Len]byte
		}
	iota 常量生成器（枚举）
		第一个声明变量的所在行，iota 会置为零，然后在每一个有常量的声明行加一
		const (
			//a = (iota + 1)	// 从 1 开始
			a = iota		// 从 0 开始
			b
			c
			d
			e
			f
		)

数组
	固定长度的特定类型元素组成的序列，可以由零个或者是多个元素组成。
	元素可以通过数组的下标进行访问，内置的 len 函数将会返回数组中元素的个数
	定义数组的类型可以进行比较，那么数组也是可以直接比较的（最好可以使用 散列算法 对数组进行 hash，然后对比 hash 码

slice
	如果要判断一个 slice 是否为空，要使用 len(slice) == 0 判断而非 slice == nil 判断
	容量与长度
		容量的内容是代表底层匿名函数所包含的整个组的数量，其他没有被使用的元素是留给未来使用
		长度是代表数组中已经存在的元素数量
	
	
	
	

package 用法

http package
	handle 以及 listen 监听到 socket 后，当用户访问会为每个用户分配一个 goroutine
	http.Handle 面向对象的方式，结构体需要实现 ServeHTTP 方法才可以赋值到 http.Handle

unicode pakcage
	unicode 提供给用户了 IsDigit IsLetter IsUpper 等动作，判断字符串的类型
	
strconv package
	提供了布尔型，整数型和浮点数以及对应字符串的相互转换

